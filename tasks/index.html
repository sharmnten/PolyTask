<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>PolyTask ‚Äî All Tasks</title>
  <link rel="manifest" href="../manifest.json">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="default">
  <meta name="theme-color" content="#4f46e5">
  <meta name="color-scheme" content="light dark">
  <script src="../js/theme-init.js"></script>
  <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'><style>path{fill:%23465775}@media(prefers-color-scheme:dark){path{fill:%23a5b4fc}}</style><path d='M12 2L2 7l10 5 10-5-10-5zm0 9l2.5-1.25L12 12l-10-5v2l10 5 10-5v-2l-2.5 1.25L12 11zm0 5l2.5-1.25L12 17l-10-5v2l10 5 10-5v-2l-2.5 1.25L12 16z'/></svg>">
  <link rel="stylesheet" href="../styles.css">
  <link rel="stylesheet" href="./tasks.css">
  <script>window.APPWRITE_ENDPOINT = 'https://nyc.cloud.appwrite.io/v1';</script>
  <script src="https://cdn.jsdelivr.net/npm/appwrite@21.4.0"></script>
  <script type="module" src="../js/main.js"></script>
</head>
<body>
  <main class="card calendar-large">
      <div class="page-header">
            <h1>My Tasks</h1>
            <div class="page-header_actions">
                <label style="cursor:pointer; display:flex; align-items:center;" title="Toggle Dark Mode">
                    <input type="checkbox" id="dmToggle" class="dm-toggle" style="display:none">
                    <svg viewBox="0 0 24 24" width="20" height="20" fill="none" class="dm-icon" stroke="currentColor" stroke-width="2"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg>
                </label>
                <a href="../calendar/index.html" class="btn-outline" style="text-decoration:none;">Planner</a>
                <a href="../dashboard/index.html" class="btn-outline" style="text-decoration:none;">Dashboard</a>
            </div>
      </div>

      <div class="smart-add-box">
          <span>+</span>
          <input type="text" id="quickAddInput" placeholder="Add a new task (e.g. 'Buy milk tomorrow')" onkeydown="handleQuickAdd(event)">
      </div>

      <div class="filters-row">
          <button class="btn-outline" onclick="filterTasks('all')" id="filterAll">All</button>
          <button class="btn-outline" onclick="filterTasks('active')" id="filterActive">Active</button>
          <button class="btn-outline" onclick="filterTasks('completed')" id="filterCompleted">Done</button>
      </div>

      <div id="taskList" class="task-list">
          <p style="text-align:center; color:var(--muted);">Loading tasks...</p>
      </div>
  </main>

  <footer>
    <p>&copy; 2026 PolyTask. Made with &#10084; by Neal Sharma</p>
    <i class="fab fa-github"></i>
  </footer>

  <script>
      let currentFilter = 'all';
      let allFetchedTasks = []; // Client-side cache

      function filterTasks(type) {
          currentFilter = type;
          // Update visual state of buttons
          document.querySelectorAll('.btn-outline').forEach(b => {
              if (b.id.startsWith('filter')) b.style.background = 'transparent';
              if (b.id.startsWith('filter')) b.style.color = 'inherit';
          });
          const activeBtn = document.getElementById('filter' + type.charAt(0).toUpperCase() + type.slice(1));
          if(activeBtn) {
              activeBtn.style.background = 'var(--dark-slate)';
              activeBtn.style.color = 'white';
          }
          // Instant render from cache
          renderList(); 
      }

      async function refreshTasks() {
          const list = document.getElementById('taskList');
          // Only show loading indicator if we don't have data, or maybe subtle one
          if(allFetchedTasks.length === 0) {
            list.innerHTML = '<p style="text-align:center; color:var(--muted);">Loading tasks...</p>';
          }
          try {
             allFetchedTasks = await PolyTask.listUserTasks();
          } catch(e) { console.error('Failed to load tasks', e); }
          renderList();
      }

      function renderList() {
          const list = document.getElementById('taskList');
          
          // Apply Filter on local cache
          let tasks = allFetchedTasks;
          if (currentFilter === 'active') tasks = allFetchedTasks.filter(t => !t.complete);
          if (currentFilter === 'completed') tasks = allFetchedTasks.filter(t => t.complete);
          
          if(!tasks.length) {
              list.innerHTML = `<div style="text-align:center; padding:2rem; color:var(--muted);">No ${currentFilter} tasks found.</div>`;
              return;
          }

          // Sort: Incomplete first, then by priority
          // Create a shallow copy to avoid mutating the cached array sort order permanently if undesired (though usually fine)
          const sorted = [...tasks].sort((a,b) => (a.complete === b.complete) ? 0 : a.complete ? 1 : -1);

          list.innerHTML = '';
          sorted.forEach(t => {
              const el = document.createElement('div');
              el.className = `task-item ${t.complete ? 'completed' : ''}`;
              
              const priorityClass = (t.priority || 'medium').toLowerCase();
              const dateStr = t.due ? new Date(t.due).toLocaleDateString() : '';
              
              const categoryPill = t.category 
                ? `<span class="badge" style="background-color: ${t.color || 'var(--muted)'}; color: white; opacity: 0.9; margin-left:8px;">${t.category}</span>` 
                : '';

              el.innerHTML = `
                  <div class="checkbox-round ${t.complete ? 'checked' : ''}" onclick="toggleTask('${t.$id}', ${!t.complete})">
                     ${t.complete ? '‚úì' : ''}
                  </div>
                  <div style="flex:1;">
                      <div style="font-weight:500; font-size:1.05rem;">
                         <span class="title">${t.name}</span>
                         ${categoryPill}
                      </div>
                      <div style="font-size:0.85rem; color:var(--muted); margin-top:0.2rem;">
                          ${dateStr ? 'üìÖ ' + dateStr : ''} 
                          ${t.estimated_time ? ' ‚Ä¢ ‚è± ' + t.estimated_time + 'm' : ''}
                      </div>
                  </div>
                  <div class="task-meta">
                      <span class="badge ${priorityClass}">${t.priority || 'medium'}</span>
                      <button class="icon-btn" onclick="deleteTask('${t.$id}')" style="color:var(--coral); opacity:0.5;">&times;</button>
                  </div>
              `;
              list.appendChild(el);
          });
      }

      async function toggleTask(id, newState) {
          try {
             if (newState && PolyTask.fireConfetti) PolyTask.fireConfetti();
             
             // Optimistic Update
             const task = allFetchedTasks.find(t => t.$id === id);
             if(task) {
                 task.complete = newState;
                 renderList(); // Instant UI update
             }
             
             await PolyTask.updateUserTask(id, { complete: newState });
             // No need to refreshTasks() if optimistic update was correct, 
             // but we can background refresh to be safe or just trust the local state.
             // For safety, we can sync quietly:
             PolyTask.listUserTasks().then(fresh => { allFetchedTasks = fresh; }); 
          } catch(e) { 
              console.error(e); 
              // Revert on error
              refreshTasks();
          }
      }
      
      async function deleteTask(id) {
          if(!confirm('Delete task?')) return;
          try {
             // Optimistic Update
             allFetchedTasks = allFetchedTasks.filter(t => t.$id !== id);
             renderList();

             await PolyTask.deleteUserTask(id);
             // Background sync
             PolyTask.listUserTasks().then(fresh => { allFetchedTasks = fresh; });
          } catch(e) { 
              console.error(e); 
              refreshTasks();
          }
      }

      async function handleQuickAdd(e) {
          if(e.key !== 'Enter') return;
          const val = e.target.value.trim();
          if(!val) return;
          e.target.value = ''; // Clear immediately
          
          try {
             let payload = {
                 name: val,
                 complete: false,
                 priority: 'medium',
                 due: new Date().toISOString(),
                 assigned: null,
                 estimated_time: 15
             };
             
             // Smart Parsing logic
             if (window.PolyTask && window.PolyTask.parseSmartInput) {
                 const parsed = window.PolyTask.parseSmartInput(val);
                 if (parsed) {
                     payload.name = parsed.title || val;
                     
                     // Date handling
                     const today = new Date();
                     const todayStr = `${today.getFullYear()}-${String(today.getMonth()+1).padStart(2,'0')}-${String(today.getDate()).padStart(2,'0')}`;
                     const finalDate = parsed.date || todayStr;
                     
                     const createDateFromLocal = (dateStr, timeStr) => {
                         const [y, m, d] = dateStr.split('-').map(Number);
                         const [th, tm] = timeStr ? timeStr.split(':').map(Number) : [23, 59];
                         return new Date(y, m - 1, d, th, tm, 0);
                     };

                     // If time is provided, use it for both due and assigned
                     if (parsed.time) {
                         const dObj = createDateFromLocal(finalDate, parsed.time);
                         payload.due = dObj.toISOString();
                         payload.assigned = payload.due;
                     } else {
                         // No time, set to end of day local
                         const dObj = createDateFromLocal(finalDate, null);
                         payload.due = dObj.toISOString();
                     }

                     if(parsed.duration) payload.estimated_time = parsed.duration;
                 }
             }
             
             const newTask = await PolyTask.createUserTask(payload);
             // Add to local cache
             if(newTask) {
                 allFetchedTasks.push(newTask);
                 renderList();
                 showToast('Task added!', 'success');
             } else {
                 refreshTasks();
             }
          } catch(e) { console.error(e); showToast('Failed to add task', 'error'); }
      }

      function showToast(msg) {
          // Simple fallback toast
          const div = document.createElement('div');
          div.style.cssText = "position:fixed;bottom:20px;left:50%;transform:translateX(-50%);background:#333;color:white;padding:12px 24px;border-radius:8px;";
          div.textContent = msg;
          document.body.appendChild(div);
          setTimeout(() => div.remove(), 2000);
      }

      document.addEventListener('DOMContentLoaded', async () => {
          // Wait for PolyTask to be available
          if (!window.PolyTask) {
             await new Promise(r => {
                const i = setInterval(() => { if(window.PolyTask){clearInterval(i); r();} }, 50);
             });
          }
          
          // Load Tasks once
          await refreshTasks();

          // Set initial filter state UI
          filterTasks('all'); 
      });
  </script>
</body>
</html>