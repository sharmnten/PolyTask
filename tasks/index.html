<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>PolyTask ‚Äî All Tasks</title>
  <link rel="manifest" href="../manifest.json">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="default">
  <meta name="theme-color" content="#4f46e5">
  <meta name="color-scheme" content="light dark">
  <script src="../js/theme-init.js"></script>
  <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'><style>path{fill:%23465775}@media(prefers-color-scheme:dark){path{fill:%23a5b4fc}}</style><path d='M12 2L2 7l10 5 10-5-10-5zm0 9l2.5-1.25L12 12l-10-5v2l10 5 10-5v-2l-2.5 1.25L12 11zm0 5l2.5-1.25L12 17l-10-5v2l10 5 10-5v-2l-2.5 1.25L12 16z'/></svg>">
  <link rel="stylesheet" href="../styles.css">
  <link rel="stylesheet" href="./tasks.css">
  <script>window.APPWRITE_ENDPOINT = 'https://nyc.cloud.appwrite.io/v1';</script>
  <script src="https://cdn.jsdelivr.net/npm/appwrite@21.4.0"></script>
  <script type="module" src="../js/main.js"></script>
</head>
<body>
  <main class="card calendar-large">
      <div class="page-header">
            <h1>My Tasks</h1>
            <div class="page-header_actions">
                <label style="cursor:pointer; display:flex; align-items:center;" title="Toggle Dark Mode">
                    <input type="checkbox" id="dmToggle" class="dm-toggle" style="display:none">
                    <svg viewBox="0 0 24 24" width="20" height="20" fill="none" class="dm-icon" stroke="currentColor" stroke-width="2"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg>
                </label>
                <a href="../achievements/index.html" class="btn-outline" style="text-decoration:none;color:white;"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-award-icon lucide-award"><path d="m15.477 12.89 1.515 8.526a.5.5 0 0 1-.81.47l-3.58-2.687a1 1 0 0 0-1.197 0l-3.586 2.686a.5.5 0 0 1-.81-.469l1.514-8.526"/><circle cx="12" cy="8" r="6"/></svg></a>
                <a href="../calendar/index.html" class="btn-outline" style="text-decoration:none;">Planner</a>
                <a href="../dashboard/index.html" class="btn-outline" style="text-decoration:none;">Dashboard</a>
            </div>
      </div>

      <div class="smart-add-box">
          <span>+</span>
          <input type="text" id="quickAddInput" placeholder="Add a new task (e.g. 'Buy milk tomorrow')" onkeydown="handleQuickAdd(event)">
      </div>

      <!-- Search Bar -->
      <div class="search-box" style="margin-bottom: 1rem;">
          <input type="text" id="searchInput" placeholder="Search tasks..." style="width: 100%; padding: 0.75rem; border: 1px solid var(--border-color); border-radius: var(--radius); background: var(--bg); color: var(--primary);">
      </div>

      <!-- Bulk Actions Bar -->
      <div id="bulkActionsBar" class="bulk-actions-bar" style="display: none; margin-bottom: 1rem; padding: 0.75rem; background: var(--bg); border: 1px solid var(--border-color); border-radius: var(--radius); display: none; align-items: center; gap: 0.5rem;">
          <span id="selectedCount" style="color: var(--primary); font-weight: 600;">0 selected</span>
          <button class="btn-outline" onclick="bulkComplete()" style="padding: 0.5rem 1rem;">Complete</button>
          <button class="btn-outline" onclick="bulkDelete()" style="padding: 0.5rem 1rem; color: var(--coral);">Delete</button>
          <button class="btn-outline" onclick="bulkArchive()" style="padding: 0.5rem 1rem;">Archive</button>
          <button class="btn-outline" onclick="clearSelection()" style="padding: 0.5rem 1rem; margin-left: auto;">Clear</button>
      </div>

      <div class="filters-row">
          <button class="btn-outline" onclick="filterTasks('all')" id="filterAll">All</button>
          <button class="btn-outline" onclick="filterTasks('active')" id="filterActive">Active</button>
          <button class="btn-outline" onclick="filterTasks('completed')" id="filterCompleted">Done</button>
          <button class="btn-outline" onclick="filterTasks('archived')" id="filterArchived">Archived</button>
      </div>

      <div id="taskList" class="task-list">
          <p style="text-align:center; color:var(--muted);">Loading tasks...</p>
      </div>
  </main>

  <footer>
    <p>&copy; 2026 PolyTask. Made with &#10084; by Neal Sharma</p>
    <i class="fab fa-github"></i>
  </footer>

  <script>
      // XSS protection: escape HTML entities in user-controlled strings
      function escapeHtml(s) {
          return String(s || '').replace(/[&<>"']/g, c => ({
              '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;'
          }[c]));
      }

      // Sanitize CSS color values (only allow safe formats)
      function sanitizeColor(color) {
          if (!color) return null;
          const safe = /^(#[0-9a-fA-F]{3,8}|[a-zA-Z]+|rgba?\([^)]+\)|hsla?\([^)]+\)|var\(--[a-zA-Z0-9-]+\))$/;
          return safe.test(String(color).trim()) ? String(color).trim() : null;
      }

      let currentFilter = 'all';
      let allFetchedTasks = []; // Client-side cache
      let searchQuery = '';
      let selectedTasks = new Set();
      let undoStack = [];

      function filterTasks(type) {
          currentFilter = type;
          // Update visual state of buttons
          document.querySelectorAll('.btn-outline').forEach(b => {
              if (b.id.startsWith('filter')) b.style.background = 'transparent';
              if (b.id.startsWith('filter')) b.style.color = 'inherit';
          });
          const activeBtn = document.getElementById('filter' + type.charAt(0).toUpperCase() + type.slice(1));
          if(activeBtn) {
              activeBtn.style.background = 'var(--dark-slate)';
              activeBtn.style.color = 'white';
          }
          // Instant render from cache
          renderList(); 
      }

      async function refreshTasks() {
          const list = document.getElementById('taskList');
          // Only show loading indicator if we don't have data, or maybe subtle one
          if(allFetchedTasks.length === 0) {
            list.innerHTML = '<p style="text-align:center; color:var(--muted);">Loading tasks...</p>';
          }
          try {
             allFetchedTasks = await PolyTask.listUserTasks();
          } catch(e) { console.error('Failed to load tasks', e); }
          renderList();
      }

      function renderList() {
          const list = document.getElementById('taskList');
          
          // Apply Filter on local cache
          let tasks = allFetchedTasks;
          if (currentFilter === 'active') tasks = allFetchedTasks.filter(t => !t.complete && !t.archived);
          if (currentFilter === 'completed') tasks = allFetchedTasks.filter(t => t.complete && !t.archived);
          if (currentFilter === 'archived') tasks = allFetchedTasks.filter(t => t.archived);
          if (currentFilter === 'all') tasks = allFetchedTasks.filter(t => !t.archived);
          
          // Apply search filter
          if (searchQuery) {
              const query = searchQuery.toLowerCase();
              tasks = tasks.filter(t => 
                  t.name?.toLowerCase().includes(query) ||
                  t.category?.toLowerCase().includes(query) ||
                  t.description?.toLowerCase().includes(query)
              );
          }
          
          if(!tasks.length) {
              list.innerHTML = `<div style="text-align:center; padding:2rem; color:var(--muted);">No ${currentFilter} tasks found.</div>`;
              return;
          }

          // Sort: Incomplete first, then by priority
          const sorted = [...tasks].sort((a,b) => (a.complete === b.complete) ? 0 : a.complete ? 1 : -1);

          list.innerHTML = '';
          sorted.forEach(t => {
              const el = document.createElement('div');
              
              // Check if task is overdue
              const isOverdue = !t.complete && t.due && new Date(t.due) < new Date();
              const isSelected = selectedTasks.has(t.$id);
              
              el.className = `task-item ${t.complete ? 'completed' : ''} ${isOverdue ? 'overdue' : ''} ${isSelected ? 'selected' : ''}`;
              
              const priorityClass = (t.priority || 'medium').toLowerCase();
              const dateStr = t.due ? new Date(t.due).toLocaleDateString() : '';
              
              const safeColor = sanitizeColor(t.color) || 'var(--muted)';
              const categoryPill = t.category
                ? `<span class="badge" style="background-color: ${safeColor}; color: white; opacity: 0.9; margin-left:8px;">${escapeHtml(t.category)}</span>`
                : '';

              el.innerHTML = `
                  <input type="checkbox" class="task-select" onchange="toggleSelect('${t.$id}')" ${isSelected ? 'checked' : ''} style="margin-right: 0.5rem;">
                  <div class="checkbox-round ${t.complete ? 'checked' : ''}" onclick="toggleTask('${t.$id}', ${!t.complete})">
                     ${t.complete ? '‚úì' : ''}
                  </div>
                  <div style="flex:1; cursor: pointer;" onclick="openTaskDetails('${t.$id}')">
                      <div style="font-weight:500; font-size:1.05rem;">
                         <span class="title">${escapeHtml(t.name)}</span>
                         ${categoryPill}
                      </div>
                      <div style="font-size:0.85rem; color:var(--muted); margin-top:0.2rem;">
                          ${dateStr ? 'üìÖ ' + dateStr : ''} 
                          ${t.estimated_time ? ' ‚Ä¢ ‚è± ' + t.estimated_time + 'm' : ''}
                          ${t.description ? ' ‚Ä¢ üìù' : ''}
                      </div>
                  </div>
                  <div class="task-meta">
                      <span class="badge ${escapeHtml(priorityClass)}">${escapeHtml(t.priority || 'medium')}</span>
                      <button class="icon-btn" onclick="duplicateTask('${t.$id}')" title="Duplicate" style="opacity:0.7;">üìã</button>
                      ${t.archived ? '<button class="icon-btn" onclick="unarchiveTask(\'' + t.$id + '\')" title="Unarchive" style="opacity:0.7;">‚Ü©Ô∏è</button>' : ''}
                      <button class="icon-btn" onclick="deleteTask('${t.$id}')" style="color:var(--coral); opacity:0.5;">&times;</button>
                  </div>
              `;
              list.appendChild(el);
          });
          
          // Update selection count
          updateBulkActionsBar();
      }

      async function toggleTask(id, newState) {
          try {
             if (newState && PolyTask.fireConfetti) PolyTask.fireConfetti();
             
             // Optimistic Update
             const task = allFetchedTasks.find(t => t.$id === id);
             if(task) {
                 task.complete = newState;
                 renderList(); // Instant UI update
             }
             
             await PolyTask.updateUserTask(id, { complete: newState });
             // No need to refreshTasks() if optimistic update was correct, 
             // but we can background refresh to be safe or just trust the local state.
             // For safety, we can sync quietly:
             PolyTask.listUserTasks().then(fresh => { allFetchedTasks = fresh; }); 
          } catch(e) { 
              console.error(e); 
              // Revert on error
              refreshTasks();
          }
      }
      
      async function deleteTask(id) {
          if(!confirm('Delete task?')) return;
          try {
             // Save for undo
             const task = allFetchedTasks.find(t => t.$id === id);
             if (task) {
                 undoStack.push({ action: 'delete', task: {...task} });
             }
             
             // Optimistic Update
             allFetchedTasks = allFetchedTasks.filter(t => t.$id !== id);
             renderList();

             await PolyTask.deleteUserTask(id);
             // Background sync
             PolyTask.listUserTasks().then(fresh => { allFetchedTasks = fresh; });
             
             // Show undo option
             if (window.PolyTask?.showToast) {
                 window.PolyTask.showToast('Task deleted', 'info', { label: 'Undo', action: () => undoDelete() });
             }
          } catch(e) { 
              console.error(e); 
              refreshTasks();
          }
      }
      
      // New functions for enhancements
      function toggleSelect(id) {
          if (selectedTasks.has(id)) {
              selectedTasks.delete(id);
          } else {
              selectedTasks.add(id);
          }
          updateBulkActionsBar();
          renderList();
      }
      
      function updateBulkActionsBar() {
          const bar = document.getElementById('bulkActionsBar');
          const count = document.getElementById('selectedCount');
          if (selectedTasks.size > 0) {
              bar.style.display = 'flex';
              count.textContent = `${selectedTasks.size} selected`;
          } else {
              bar.style.display = 'none';
          }
      }
      
      function clearSelection() {
          selectedTasks.clear();
          updateBulkActionsBar();
          renderList();
      }
      
      async function bulkComplete() {
          if (selectedTasks.size === 0) return;
          const ids = Array.from(selectedTasks);
          for (const id of ids) {
              await toggleTask(id, true);
          }
          clearSelection();
      }
      
      async function bulkDelete() {
          if (selectedTasks.size === 0) return;
          if (!confirm(`Delete ${selectedTasks.size} tasks?`)) return;
          const ids = Array.from(selectedTasks);
          for (const id of ids) {
              const task = allFetchedTasks.find(t => t.$id === id);
              if (task) {
                  await PolyTask.deleteUserTask(id);
                  allFetchedTasks = allFetchedTasks.filter(t => t.$id !== id);
              }
          }
          clearSelection();
          renderList();
      }
      
      async function bulkArchive() {
          if (selectedTasks.size === 0) return;
          const ids = Array.from(selectedTasks);
          for (const id of ids) {
              await archiveTask(id);
          }
          clearSelection();
      }
      
      async function duplicateTask(id) {
          const task = allFetchedTasks.find(t => t.$id === id);
          if (!task) return;
          
          const payload = {
              name: task.name + ' (Copy)',
              complete: false,
              priority: task.priority,
              due: task.due,
              assigned: task.assigned,
              estimated_time: task.estimated_time,
              category: task.category,
              color: task.color,
              description: task.description
          };
          
          try {
              const newTask = await PolyTask.createUserTask(payload);
              if (newTask) {
                  allFetchedTasks.push(newTask);
                  renderList();
                  if (window.PolyTask?.showToast) {
                      window.PolyTask.showToast('Task duplicated', 'success');
                  }
              }
          } catch(e) {
              console.error(e);
          }
      }
      
      async function archiveTask(id) {
          try {
              const task = allFetchedTasks.find(t => t.$id === id);
              if (task) {
                  task.archived = true;
                  await PolyTask.updateUserTask(id, { archived: true });
                  renderList();
                  if (window.PolyTask?.showToast) {
                      window.PolyTask.showToast('Task archived', 'info');
                  }
              }
          } catch(e) {
              console.error(e);
          }
      }
      
      async function unarchiveTask(id) {
          try {
              const task = allFetchedTasks.find(t => t.$id === id);
              if (task) {
                  task.archived = false;
                  await PolyTask.updateUserTask(id, { archived: false });
                  renderList();
                  if (window.PolyTask?.showToast) {
                      window.PolyTask.showToast('Task restored', 'success');
                  }
              }
          } catch(e) {
              console.error(e);
          }
      }
      
      function undoDelete() {
          if (undoStack.length === 0) return;
          const lastAction = undoStack.pop();
          if (lastAction.action === 'delete') {
              // Restore the task
              PolyTask.createUserTask(lastAction.task).then(newTask => {
                  if (newTask) {
                      allFetchedTasks.push(newTask);
                      renderList();
                  }
              });
          }
      }
      
      function openTaskDetails(id) {
          const task = allFetchedTasks.find(t => t.$id === id);
          if (!task) return;
          
          const description = prompt(`Description for "${task.name}":`, task.description || '');
          if (description !== null) {
              task.description = description;
              PolyTask.updateUserTask(id, { description });
              renderList();
          }
      }
      
      // Search functionality
      function initSearch() {
          const searchInput = document.getElementById('searchInput');
          if (searchInput) {
              searchInput.addEventListener('input', (e) => {
                  searchQuery = e.target.value.trim();
                  renderList();
              });
          }
      }
      
      // Keyboard shortcuts
      function initKeyboardShortcuts() {
          document.addEventListener('keydown', (e) => {
              // Only activate if not typing in an input
              if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                  // Allow Cmd/Ctrl+K even in inputs
                  if ((e.metaKey || e.ctrlKey) && e.key === 'k') {
                      e.preventDefault();
                      document.getElementById('searchInput')?.focus();
                  }
                  return;
              }
              
              // N - New task
              if (e.key === 'n' || e.key === 'N') {
                  e.preventDefault();
                  document.getElementById('quickAddInput')?.focus();
              }
              
              // / - Search
              if (e.key === '/') {
                  e.preventDefault();
                  document.getElementById('searchInput')?.focus();
              }
              
              // D - Dashboard
              if ((e.shiftKey && e.key === 'D') || (e.key === 'd' && e.shiftKey)) {
                  e.preventDefault();
                  window.location.href = '../dashboard/index.html';
              }
              
              // C - Calendar
              if ((e.shiftKey && e.key === 'C') || (e.key === 'c' && e.shiftKey)) {
                  e.preventDefault();
                  window.location.href = '../calendar/index.html';
              }
              
              // Ctrl/Cmd + Z - Undo
              if ((e.metaKey || e.ctrlKey) && e.key === 'z') {
                  e.preventDefault();
                  undoDelete();
              }
              
              // Escape - Clear selection
              if (e.key === 'Escape') {
                  clearSelection();
              }
          });
      }

      async function handleQuickAdd(e) {
          if(e.key !== 'Enter') return;
          const val = e.target.value.trim();
          if(!val) return;
          e.target.value = ''; // Clear immediately
          
          try {
             let payload = {
                 name: val,
                 complete: false,
                 priority: 'medium',
                 due: new Date().toISOString(),
                 assigned: null,
                 estimated_time: 15
             };
             
             // Smart Parsing logic
             if (window.PolyTask && window.PolyTask.parseSmartInput) {
                 const parsed = window.PolyTask.parseSmartInput(val);
                 if (parsed) {
                     payload.name = parsed.title || val;
                     
                     // Date handling
                     const today = new Date();
                     const todayStr = `${today.getFullYear()}-${String(today.getMonth()+1).padStart(2,'0')}-${String(today.getDate()).padStart(2,'0')}`;
                     const finalDate = parsed.date || todayStr;
                     
                     const createDateFromLocal = (dateStr, timeStr) => {
                         const [y, m, d] = dateStr.split('-').map(Number);
                         const [th, tm] = timeStr ? timeStr.split(':').map(Number) : [23, 59];
                         return new Date(y, m - 1, d, th, tm, 0);
                     };

                     // If time is provided, use it for both due and assigned
                     if (parsed.time) {
                         const dObj = createDateFromLocal(finalDate, parsed.time);
                         payload.due = dObj.toISOString();
                         payload.assigned = payload.due;
                     } else {
                         // No time, set to end of day local
                         const dObj = createDateFromLocal(finalDate, null);
                         payload.due = dObj.toISOString();
                     }

                     if(parsed.duration) payload.estimated_time = parsed.duration;
                 }
             }
             
             const newTask = await PolyTask.createUserTask(payload);
             // Add to local cache
             if(newTask) {
                 allFetchedTasks.push(newTask);
                 renderList();
                 showToast('Task added!', 'success');
             } else {
                 refreshTasks();
             }
          } catch(e) { console.error(e); showToast('Failed to add task', 'error'); }
      }

      function showToast(msg) {
          // Simple fallback toast
          const div = document.createElement('div');
          div.style.cssText = "position:fixed;bottom:20px;left:50%;transform:translateX(-50%);background:#333;color:white;padding:12px 24px;border-radius:8px;";
          div.textContent = msg;
          document.body.appendChild(div);
          setTimeout(() => div.remove(), 2000);
      }

      document.addEventListener('DOMContentLoaded', async () => {
          // Wait for PolyTask to be available
          if (!window.PolyTask) {
             await new Promise(r => {
                const i = setInterval(() => { if(window.PolyTask){clearInterval(i); r();} }, 50);
             });
          }
          
          // Load Tasks once
          await refreshTasks();

          // Set initial filter state UI
          filterTasks('all');
          
          // Initialize search
          initSearch();
          
          // Initialize keyboard shortcuts
          initKeyboardShortcuts();
          
          // Show keyboard shortcuts help on first visit
          if (!localStorage.getItem('shortcuts_seen')) {
              setTimeout(() => {
                  if (window.PolyTask?.showToast) {
                      window.PolyTask.showToast('üí° Press ? for keyboard shortcuts', 'info');
                  }
                  localStorage.setItem('shortcuts_seen', 'true');
              }, 2000);
          }
      });
  </script>
</body>
</html>